---
# GraphQL Application Code
apiVersion: v1
kind: ConfigMap
metadata:
  name: graphql-code-config
  namespace: graphql-system
  labels:
    app: hospital-management-system
    component: api
    system: graphql
data:
  package-json: |
    {
      "name": "hms-graphql-api",
      "version": "1.0.0",
      "description": "Unified GraphQL API for Ultimate HMS",
      "main": "index.js",
      "scripts": {
        "start": "node index.js"
      },
      "dependencies": {}
    }

  tsconfig-json: |
    {
      "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "lib": ["ES2020"],
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "resolveJsonModule": true
      },
      "include": ["src/**/*"],
      "exclude": ["node_modules", "dist"]
    }

  src-index-ts: |
    import { ApolloServer } from 'apollo-server';
    import { createRedisClient } from './redis';
    import { createElasticsearchClient } from './elasticsearch';
    import { createOpenMRSClient } from './openmrs';
    import { createMetasfreshClient } from './metasfresh';
    import { typeDefs, resolvers } from './schema';
    import { createAuthMiddleware } from './auth';

    const PORT = process.env.PORT || 4000;

    async function startServer() {
      // Initialize clients
      const redis = createRedisClient();
      const elasticsearch = createElasticsearchClient();
      const openmrs = createOpenMRSClient();
      const metasfresh = createMetasfreshClient();

      // Create Apollo Server
      const server = new ApolloServer({
        typeDefs,
        resolvers,
        context: ({ req }) => ({
          redis,
          elasticsearch,
          openmrs,
          metasfresh,
          user: req.user
        }),
        introspection: process.env.NODE_ENV !== 'production',
        playground: process.env.NODE_ENV !== 'production'
      });

      // Start server
      const { url } = await server.listen({ port: PORT });
      console.log(`ðŸš€ GraphQL API ready at ${url}`);
      console.log(`ðŸ“Š Health check at ${url.replace('/graphql', '/health')}`);
    }

    startServer().catch(console.error);

  src-schema-ts: |
    import { gql } from 'apollo-server';

    export const typeDefs = gql`
      type Query {
        # Patient queries
        patients(limit: Int, offset: Int): [Patient!]!
        patient(uuid: ID!): Patient

        # Encounter queries
        encounters(patientUuid: ID, limit: Int, offset: Int): [Encounter!]!
        encounter(uuid: ID!): Encounter

        # Business Partner queries (Metasfresh)
        businessPartners(limit: Int, offset: Int): [BusinessPartner!]!
        businessPartner(id: ID!): BusinessPartner

        # Product queries (Metasfresh)
        products(limit: Int, offset: Int): [Product!]!
        product(id: ID!): Product

        # Search across systems
        search(query: String!, type: SearchType): [SearchResult!]!
      }

      type Mutation {
        # Patient mutations
        createPatient(input: PatientInput!): Patient!
        updatePatient(uuid: ID!, input: PatientInput!): Patient!

        # Encounter mutations
        createEncounter(input: EncounterInput!): Encounter!

        # Business Partner mutations
        createBusinessPartner(input: BusinessPartnerInput!): BusinessPartner!
        updateBusinessPartner(id: ID!, input: BusinessPartnerInput!): BusinessPartner!
      }

      # Patient types
      type Patient {
        uuid: ID!
        identifiers: [PatientIdentifier!]!
        person: Person!
        encounters: [Encounter!]!
      }

      type Person {
        uuid: ID!
        names: [PersonName!]!
        gender: Gender
        birthdate: String
        addresses: [PersonAddress!]!
      }

      type PersonName {
        givenName: String!
        middleName: String
        familyName: String!
      }

      type PersonAddress {
        address1: String
        address2: String
        cityVillage: String
        stateProvince: String
        country: String
        postalCode: String
      }

      type PatientIdentifier {
        identifier: String!
        identifierType: IdentifierType!
      }

      type IdentifierType {
        uuid: ID!
        name: String!
      }

      # Encounter types
      type Encounter {
        uuid: ID!
        encounterType: EncounterType!
        patient: Patient!
        encounterDatetime: String!
        location: Location
        obs: [Observation!]!
      }

      type EncounterType {
        uuid: ID!
        name: String!
      }

      type Location {
        uuid: ID!
        name: String!
      }

      type Observation {
        uuid: ID!
        concept: Concept!
        value: String
      }

      type Concept {
        uuid: ID!
        name: String!
      }

      # Metasfresh types
      type BusinessPartner {
        id: ID!
        name: String!
        value: String!
        addresses: [BusinessPartnerAddress!]!
        contacts: [BusinessPartnerContact!]!
      }

      type BusinessPartnerAddress {
        id: ID!
        address1: String
        city: String
        postal: String
        countryCode: String
      }

      type BusinessPartnerContact {
        id: ID!
        name: String!
        email: String
        phone: String
      }

      type Product {
        id: ID!
        name: String!
        value: String!
        uom: UOM!
        price: Float
      }

      type UOM {
        id: ID!
        name: String!
        symbol: String
      }

      # Search types
      enum SearchType {
        PATIENT
        BUSINESS_PARTNER
        PRODUCT
        ALL
      }

      union SearchResult = Patient | BusinessPartner | Product

      # Enums
      enum Gender {
        M
        F
        O
      }

      # Input types
      input PatientInput {
        names: [PersonNameInput!]!
        gender: Gender
        birthdate: String
        addresses: [PersonAddressInput!]
        identifiers: [PatientIdentifierInput!]
      }

      input PersonNameInput {
        givenName: String!
        middleName: String
        familyName: String!
      }

      input PersonAddressInput {
        address1: String
        address2: String
        cityVillage: String
        stateProvince: String
        country: String
        postalCode: String
      }

      input PatientIdentifierInput {
        identifier: String!
        identifierTypeUuid: ID!
      }

      input EncounterInput {
        patientUuid: ID!
        encounterTypeUuid: ID!
        encounterDatetime: String
        locationUuid: ID
        obs: [ObservationInput!]
      }

      input ObservationInput {
        conceptUuid: ID!
        value: String!
      }

      input BusinessPartnerInput {
        name: String!
        value: String!
        addresses: [BusinessPartnerAddressInput!]
        contacts: [BusinessPartnerContactInput!]
      }

      input BusinessPartnerAddressInput {
        address1: String
        city: String
        postal: String
        countryCode: String
      }

      input BusinessPartnerContactInput {
        name: String!
        email: String
        phone: String
      }
    `;

    export const resolvers = {
      Query: {
        patients: async (_, { limit = 10, offset = 0 }, { openmrs }) => {
          return await openmrs.getPatients({ limit, offset });
        },
        patient: async (_, { uuid }, { openmrs }) => {
          return await openmrs.getPatient(uuid);
        },
        encounters: async (_, { patientUuid, limit = 10, offset = 0 }, { openmrs }) => {
          return await openmrs.getEncounters({ patientUuid, limit, offset });
        },
        encounter: async (_, { uuid }, { openmrs }) => {
          return await openmrs.getEncounter(uuid);
        },
        businessPartners: async (_, { limit = 10, offset = 0 }, { metasfresh }) => {
          return await metasfresh.getBusinessPartners({ limit, offset });
        },
        businessPartner: async (_, { id }, { metasfresh }) => {
          return await metasfresh.getBusinessPartner(id);
        },
        products: async (_, { limit = 10, offset = 0 }, { metasfresh }) => {
          return await metasfresh.getProducts({ limit, offset });
        },
        product: async (_, { id }, { metasfresh }) => {
          return await metasfresh.getProduct(id);
        },
        search: async (_, { query, type }, { elasticsearch }) => {
          return await elasticsearch.search(query, type);
        }
      },
      Mutation: {
        createPatient: async (_, { input }, { openmrs }) => {
          return await openmrs.createPatient(input);
        },
        updatePatient: async (_, { uuid, input }, { openmrs }) => {
          return await openmrs.updatePatient(uuid, input);
        },
        createEncounter: async (_, { input }, { openmrs }) => {
          return await openmrs.createEncounter(input);
        },
        createBusinessPartner: async (_, { input }, { metasfresh }) => {
          return await metasfresh.createBusinessPartner(input);
        },
        updateBusinessPartner: async (_, { id, input }, { metasfresh }) => {
          return await metasfresh.updateBusinessPartner(id, input);
        }
      },
      SearchResult: {
        __resolveType(obj) {
          if (obj.uuid && obj.person) return 'Patient';
          if (obj.id && obj.name && obj.addresses) return 'BusinessPartner';
          if (obj.id && obj.name && obj.uom) return 'Product';
          return null;
        }
      }
    };

  src-redis-ts: |
    import { createClient } from 'redis';

    export function createRedisClient() {
      const client = createClient({
        url: process.env.REDIS_URL,
        password: process.env.REDIS_PASSWORD
      });

      client.on('error', (err) => console.error('Redis Client Error', err));

      return client;
    }

  src-elasticsearch-ts: |
    import { Client } from '@elastic/elasticsearch';

    export function createElasticsearchClient() {
      return new Client({
        node: process.env.ELASTICSEARCH_URL
      });
    }

  src-openmrs-ts: |
    import axios from 'axios';

    export function createOpenMRSClient() {
      const client = axios.create({
        baseURL: process.env.OPENMRS_API_URL,
        auth: {
          username: process.env.OPENMRS_USERNAME!,
          password: process.env.OPENMRS_PASSWORD!
        }
      });

      return {
        async getPatients({ limit, offset }: { limit: number; offset: number }) {
          const response = await client.get('/openmrs/ws/rest/v1/patient', {
            params: { limit, startIndex: offset }
          });
          return response.data.results;
        },

        async getPatient(uuid: string) {
          const response = await client.get(`/openmrs/ws/rest/v1/patient/${uuid}`);
          return response.data;
        },

        async getEncounters({ patientUuid, limit, offset }: { patientUuid?: string; limit: number; offset: number }) {
          const params: any = { limit, startIndex: offset };
          if (patientUuid) params.patient = patientUuid;

          const response = await client.get('/openmrs/ws/rest/v1/encounter', { params });
          return response.data.results;
        },

        async getEncounter(uuid: string) {
          const response = await client.get(`/openmrs/ws/rest/v1/encounter/${uuid}`);
          return response.data;
        },

        async createPatient(input: any) {
          const response = await client.post('/openmrs/ws/rest/v1/patient', input);
          return response.data;
        },

        async updatePatient(uuid: string, input: any) {
          const response = await client.post(`/openmrs/ws/rest/v1/patient/${uuid}`, input);
          return response.data;
        },

        async createEncounter(input: any) {
          const response = await client.post('/openmrs/ws/rest/v1/encounter', input);
          return response.data;
        }
      };
    }

  src-metasfresh-ts: |
    import axios from 'axios';

    export function createMetasfreshClient() {
      const client = axios.create({
        baseURL: process.env.METASFRESH_API_URL,
        auth: {
          username: process.env.METASFRESH_USERNAME!,
          password: process.env.METASFRESH_PASSWORD!
        }
      });

      return {
        async getBusinessPartners({ limit, offset }: { limit: number; offset: number }) {
          // Metasfresh API endpoints - adjust based on actual API
          const response = await client.get('/api/business-partners', {
            params: { limit, offset }
          });
          return response.data;
        },

        async getBusinessPartner(id: string) {
          const response = await client.get(`/api/business-partners/${id}`);
          return response.data;
        },

        async getProducts({ limit, offset }: { limit: number; offset: number }) {
          const response = await client.get('/api/products', {
            params: { limit, offset }
          });
          return response.data;
        },

        async getProduct(id: string) {
          const response = await client.get(`/api/products/${id}`);
          return response.data;
        },

        async createBusinessPartner(input: any) {
          const response = await client.post('/api/business-partners', input);
          return response.data;
        },

        async updateBusinessPartner(id: string, input: any) {
          const response = await client.put(`/api/business-partners/${id}`, input);
          return response.data;
        }
      };
    }

  src-auth-ts: |
    import jwt from 'jsonwebtoken';

    export function createAuthMiddleware() {
      return (req: any, res: any, next: any) => {
        const token = req.headers.authorization?.replace('Bearer ', '');

        if (token) {
          try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET!);
            req.user = decoded;
          } catch (err) {
            // Invalid token
          }
        }

        next();
      };
    }

  src-health-ts: |
    import express from 'express';

    const app = express();

    app.get('/health', (req, res) => {
      res.status(200).json({ status: 'healthy', timestamp: new Date().toISOString() });
    });

    export default app;